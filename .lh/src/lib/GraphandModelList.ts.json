{
    "sourceFile": "src/lib/GraphandModelList.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1683910921796,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1683910926921,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,9 +17,8 @@\n     }\n \n     if (rows?.length) {\n       Array.prototype.push.apply(elements, rows);\n-      elements = elements.concat(rows);\n     }\n \n     if (!model) {\n       // @ts-ignore\n"
                },
                {
                    "date": 1683910938729,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,10 +20,9 @@\n       Array.prototype.push.apply(elements, rows);\n     }\n \n     if (!model) {\n-      // @ts-ignore\n-      return super(...elements);\n+      return Array.from(...elements);\n     }\n \n     super(...elements);\n \n"
                },
                {
                    "date": 1683910974506,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,8 +20,9 @@\n       Array.prototype.push.apply(elements, rows);\n     }\n \n     if (!model) {\n+      // @ts-ignore\n       return Array.from(elements);\n     }\n \n     super(...elements);\n"
                },
                {
                    "date": 1683910987077,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,9 +21,9 @@\n     }\n \n     if (!model) {\n       // @ts-ignore\n-      return Array.from(elements);\n+      return super(...elements);\n     }\n \n     super(...elements);\n \n"
                }
            ],
            "date": 1683910921795,
            "name": "Commit-0",
            "content": "import { Observable, Subscription } from \"rxjs\";\nimport GraphandModel from \"./GraphandModel\";\nimport GraphandModelListPromise from \"./GraphandModelListPromise\";\n\n/**\n * @class GraphandModelList\n */\nclass GraphandModelList<T extends GraphandModel> extends Array<T> {\n  count;\n  private _observable;\n  private _storeSub;\n  private _subscriptions;\n\n  constructor({ model, count, query, rows }: { model?; count?; query?; rows? }, ...elements) {\n    if (!elements?.length) {\n      elements = [];\n    }\n\n    if (rows?.length) {\n      Array.prototype.push.apply(elements, rows);\n      elements = elements.concat(rows);\n    }\n\n    if (!model) {\n      // @ts-ignore\n      return super(...elements);\n    }\n\n    super(...elements);\n\n    this._model = model;\n    this.count = count || 0;\n    this._query = query;\n    this._subscriptions = new Set();\n\n    Object.defineProperty(this, \"_model\", { enumerable: false });\n    Object.defineProperty(this, \"count\", { enumerable: false });\n    Object.defineProperty(this, \"_query\", { enumerable: false });\n  }\n\n  _model;\n  _query;\n\n  /**\n   * @readonly\n   * @type {GraphandModel}\n   * @public\n   */\n  get model() {\n    return this._model || this[0]?.constructor;\n  }\n\n  /**\n   * @readonly\n   * @type {any}\n   * @public\n   */\n  get query() {\n    return this._query || { ids: this.ids };\n  }\n\n  /**\n   * @readonly\n   * @type {string[]}\n   * @public\n   */\n  get ids() {\n    return this.toArray()\n      .map((item) => item?._id || String(item))\n      .filter(Boolean) as string[];\n  }\n\n  /**\n   * @readonly\n   * @type {GraphandModelListPromise}\n   * @public\n   */\n  get promise() {\n    return new GraphandModelListPromise(\n      (resolve) => {\n        resolve(this);\n      },\n      this.model,\n      this.query,\n    );\n  }\n\n  /**\n   * Hydrate GraphandModelList from serialized data\n   * @param data {any} - Serialized data\n   * @returns {GraphandModelList}\n   */\n  static hydrate(data: any, model: any) {\n    if (!model) {\n      throw new Error(`You need to provide a model to hydrate a new GraphandModelList`);\n    }\n\n    data = data ?? {};\n\n    if (Array.isArray(data)) {\n      const list = data.map((i) => new model(i));\n      return new GraphandModelList({ model }, ...list);\n    }\n\n    const { __count: count, __query: query, __payload } = data;\n    const items = __payload ? __payload.map((i) => model.hydrate(i)) : [];\n    return new GraphandModelList({ model, count, query }, ...items);\n  }\n\n  toArray() {\n    return new Array<T>(...this);\n  }\n\n  clone(concatWith?: T | GraphandModelList<T>) {\n    let concatArray: ConcatArray<T>;\n    if (Array.isArray(concatWith)) {\n      concatArray = concatWith.toArray?.() || concatWith;\n    } else if (concatWith) {\n      concatArray = [concatWith];\n    }\n\n    const elements = concatArray?.length ? this.toArray().concat(concatArray) : this.toArray();\n    return new GraphandModelList(this, ...elements);\n  }\n\n  async reload() {\n    const list = await this.model.getList(this.query);\n    this.splice(0, this.length, ...list);\n    this.count = list.count;\n    return this;\n  }\n\n  createObservable() {\n    this._observable = new Observable((subscriber) => {\n      let prevLastUpdated = this.map((i) => i.updatedAt).sort((a, b) => b.getTime() - a.getTime())[0];\n\n      const _updater = async () => {\n        await new Promise((resolve) => setTimeout(resolve));\n        const list = await this.model.getList(this.query);\n        const lastUpdated = list.map((i) => i.updatedAt).sort((a, b) => b - a)[0];\n\n        if (this.length !== list.length || this.count !== list.count || lastUpdated > prevLastUpdated) {\n          prevLastUpdated = lastUpdated;\n\n          this.splice(0, this.length, ...list.toArray());\n          this.count = list.count;\n\n          subscriber.next(this);\n        }\n      };\n\n      this._storeSub = this.model._listSubject.subscribe(_updater);\n    });\n  }\n\n  /**\n   * Subscribe to the list. The callback will be called each time (an instance inside) the list is updated in store.\n   * If the model is synced (realtime), the callback will be called when the list is updated via socket\n   * @param callback - The function to call when the list is updated\n   */\n  subscribe(callback): Subscription {\n    if (!this._observable) {\n      this.createObservable();\n    }\n\n    const sub = this._observable.subscribe(callback);\n    this._subscriptions.add(sub);\n    const unsubscribe = sub.unsubscribe;\n    sub.unsubscribe = () => {\n      unsubscribe.apply(sub);\n      this._subscriptions.delete(sub);\n\n      if (!this._subscriptions.size) {\n        this._storeSub?.unsubscribe();\n        delete this._observable;\n      }\n    };\n\n    sub.next(this);\n    return sub;\n  }\n\n  encodeQuery() {\n    return this.ids;\n  }\n\n  toString(): string {\n    return JSON.stringify(this.ids);\n  }\n\n  toJSON() {\n    return this.map((i) => i.toJSON?.apply(i) || i);\n  }\n\n  /**\n   * Serialize list. Serialized data could be hydrated with GraphandModel.hydrate\n   * @returns {Object}\n   */\n  serialize() {\n    return {\n      __type: \"GraphandModelList\",\n      __scope: this.model.scope,\n      __count: this.count,\n      __query: this.query,\n      __payload: this.map((i) => i.serialize?.apply(i) || i),\n    };\n  }\n}\n\nexport default GraphandModelList;\n"
        }
    ]
}