{
    "sourceFile": "src/lib/GraphandModel.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1683910162845,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1683910229554,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -748,10 +748,10 @@\n     query: Query,\n     opts?: ModelListOptions | boolean,\n   ): GraphandModelList<InstanceType<T>> | GraphandModelListPromise<InstanceType<T>> {\n     if (!query) {\n-      const list = this._listSubject.getValue() || [];\n-      return new GraphandModelList<InstanceType<T>>({ model: this }, ...list);\n+      const rows = this._listSubject.getValue() || [];\n+      return new GraphandModelList<InstanceType<T>>({ model: this, rows });\n     }\n \n     return getModelList(this, query, opts);\n   }\n"
                }
            ],
            "date": 1683910162845,
            "name": "Commit-0",
            "content": "import copy from \"fast-copy\";\nimport { get as lodashGet, set as lodashSet } from \"lodash\";\nimport { BehaviorSubject, Observable, Subject, Subscription } from \"rxjs\";\nimport ClientHooksEvents from \"../enums/client-hooks-events\";\nimport ModelEnvScopes from \"../enums/model-env-scopes\";\nimport ModelScopes from \"../enums/model-scopes\";\nimport ServerHooksEvents from \"../enums/server-hooks-events\";\nimport GraphandClient, { RegisterHookOptions } from \"../GraphandClient\";\nimport Account from \"../models/Account\";\nimport createModel from \"../utils/createModel\";\nimport { ownProperty } from \"../utils/decorators\";\nimport deleteModel from \"../utils/deleteModel\";\nimport { FetchOptions } from \"../utils/fetchModel\";\nimport getModelInstance from \"../utils/getModelInstance\";\nimport getModelList, { ModelListOptions } from \"../utils/getModelList\";\nimport hydrateModel from \"../utils/hydrateModel\";\nimport isId from \"../utils/isId\";\nimport parsePayload from \"../utils/parsePayload\";\nimport parseQuery from \"../utils/parseQuery\";\nimport processPopulate from \"../utils/processPopulate\";\nimport updateModel, { updateModelInstance } from \"../utils/updateModel\";\nimport GraphandFieldDate from \"./fields/GraphandFieldDate\";\nimport GraphandFieldId from \"./fields/GraphandFieldId\";\nimport GraphandFieldRelation from \"./fields/GraphandFieldRelation\";\nimport GraphandError from \"./GraphandError\";\nimport GraphandField from \"./GraphandField\";\nimport GraphandModelList from \"./GraphandModelList\";\nimport GraphandModelListPromise from \"./GraphandModelListPromise\";\nimport GraphandModelPromise from \"./GraphandModelPromise\";\n\ntype ClientHookCallbackBase<T extends any[]> = (...args: T) => void | false;\n\ntype ClientHookArgs<T extends ClientHooksEvents | string, M extends GraphandModel> = T extends ClientHooksEvents.preCreate | \"preCreate\"\n  ? [{ payload: any; config: any } & any]\n  : T extends ClientHooksEvents.postCreate | \"postCreate\"\n  ? [M[] | null, GraphandError | null, ClientHookArgs<\"preCreate\", M>[0]]\n  : T extends ClientHooksEvents.preUpdate | \"preUpdate\"\n  ? [{ payload: any; instance?: M; config: any } & any]\n  : T extends ClientHooksEvents.postUpdate | \"postUpdate\"\n  ? [M[] | null, GraphandError | null, ClientHookArgs<\"preUpdate\", M>[0]]\n  : T extends ClientHooksEvents.preDelete | \"preDelete\"\n  ? [{ payload: any } & any]\n  : T extends ClientHooksEvents.postDelete | \"postDelete\"\n  ? [GraphandError | null, ClientHookArgs<\"preDelete\", M>[0]]\n  : any;\n\ntype ClientHookCallback<T extends ClientHooksEvents | string, M extends GraphandModel> = ClientHookCallbackBase<ClientHookArgs<T, M>>;\n\ninterface Query {\n  query?: any;\n  ids?: string[];\n  sort?: string | any;\n  page?: number;\n  pageSize?: number;\n  populate?: string | any;\n  count?: boolean;\n  translations?: string[];\n}\n\ninterface Update {\n  query?: any;\n  ids?: string[];\n  sort?: string | any;\n  page?: number;\n  pageSize?: number;\n  populate?: string | any;\n  set?: any;\n}\n\nclass AbstractGraphandModel {\n  static __proto__: any;\n  static scope?: ModelScopes | string;\n  static Scopes = ModelScopes;\n}\n\n/**\n * @class GraphandModel\n * @classdesc Base GraphandModel class. You can create your own custom models by extending this class.\n */\nclass GraphandModel extends AbstractGraphandModel {\n  /**\n   * Model fetching options\n   * @typedef Query\n   * @property [query] {Object} - A mongo query, cf. graphand API documentation\n   * @property [ids] {string[]} - A list of ids to query\n   * @property [sort] {string|Object}\n   * @property [page] {number}\n   * @property [pageSize] {number}\n   * @property [populate] {string|Object}\n   */\n\n  /**\n   * Model updating options for {@link GraphandModel#update}\n   * @typedef Update\n   * @property [query] {Object} - A mongo query, cf. graphand API documentation\n   * @property [ids] {string[]} - A list of ids to query\n   * @property [sort] {string|Object}\n   * @property [page] {number}\n   * @property [pageSize] {number}\n   * @property [populate] {string|Object}\n   * @property [set] {Object} - The payload to apply on target instances\n   */\n\n  /**\n   * Model fetching options\n   * @typedef FetchOptions\n   * @property cache {boolean}\n   * @property hooks {boolean}\n   * @property authToken {string}\n   * @property global {boolean}\n   * @property axiosOpts {AxiosRequestConfig}\n   */\n\n  /**\n   * Model fetching options\n   * @typedef ModelScopes\n   * @property scope {\"Account\"|\"Aggregation\"|\"DataField\"|\"DataModel\"|\"Environment\"|\"EsMapping\"|\"Log\"|\"Media\"|\"Project\"|\"Restriction\"|\"Role\"|\"Rule\"|\"Sockethook\"|\"Token\"|\"User\"|\"Webhook\"}\n   */\n\n  /**\n   * Model getList options\n   * @typedef ModelListOptions\n   * @property fetch {FetchOptions|boolean}\n   * @property cache {boolean}\n   */\n\n  // configurable fields\n  static scope: ModelScopes;\n  static envScope: ModelEnvScopes;\n  static translatable = true;\n  static queryFields = false;\n  static isGlobal = false;\n  static baseUrl = null;\n  static queryUrl = null;\n  static schema: { [key: string]: GraphandField } = {};\n  static initialize: () => any;\n\n  /**\n   * @member {ModelScopes}\n   */\n  static Scopes = ModelScopes;\n\n  /** @member {GraphandClient} */\n  @ownProperty()\n  static _client: GraphandClient;\n  @ownProperty()\n  static _socketSubscription;\n  @ownProperty()\n  static _fieldsIds;\n  @ownProperty(() => ({}))\n  static _dataFields;\n  @ownProperty(() => ({}))\n  static _cache;\n  @ownProperty()\n  static _initialized;\n  @ownProperty(() => new Set())\n  static _observers;\n  @ownProperty(() => new Subject())\n  static _socketTriggerSubject;\n  @ownProperty()\n  static _initPromise;\n  @ownProperty(() => new BehaviorSubject([]))\n  static _listSubject;\n  @ownProperty(() => ({}))\n  static _socketOptions;\n  @ownProperty(() => ({}), (a, b) => ({ ...a, ...b }))\n  static _customFields;\n  @ownProperty()\n  static _cachedFields;\n  @ownProperty(() => ({}))\n  static _hooks;\n  @ownProperty(() => new Set())\n  static _queryIds;\n  @ownProperty()\n  static _queryIdsTimeout;\n  @ownProperty()\n  static _dataFieldsList;\n\n  static _promiseAvailableMethods = [];\n\n  _data: any = {};\n  _locale = null;\n  _observable;\n  _storeSub;\n  _subscriptions = new Set();\n  _model: typeof GraphandModel;\n\n  _id: string;\n  _iat: number;\n  createdAt: Date;\n  updatedAt: Date;\n  createdBy: Account;\n  updatedBy: Account;\n  [prop: string]: any;\n\n  /**\n   * Create a new instance of GraphandModel. If getting an instance as data, the instance will be cloned\n   * @param data {*}\n   * @return {GraphandModel}\n   */\n  constructor(data: any = {}) {\n    super();\n\n    const { constructor } = Object.getPrototypeOf(this);\n    this._model = constructor;\n\n    if (!constructor._client) {\n      throw new Error(`Model ${constructor.scope} is not register. Please use Client.registerModel() before`);\n    }\n\n    if (!constructor._initialized) {\n      console.warn(`Model ${constructor.scope} is not initialized yet. You should wait Model._init() before call constructor`);\n    }\n\n    if (data instanceof GraphandModel) {\n      return data.clone();\n    }\n\n    this._iat = Date.now();\n    this._id = data._id || `_${this._iat}`;\n    this._data = Object.assign({}, data);\n\n    Object.defineProperty(this, \"_data\", { enumerable: false });\n    Object.defineProperty(this, \"_locale\", { enumerable: false });\n\n    if (constructor.queryFields && constructor._client._options.subscribeFields) {\n      constructor._init().then(() => constructor.dataFieldsList.subscribe(() => setTimeout(() => constructor.setPrototypeFields(this))));\n    } else {\n      constructor.setPrototypeFields(this);\n    }\n  }\n\n  /**\n   * Description of the function\n   * @callback GraphandModel.sync.handleSocketTrigger\n   * @params opts {Object}\n   * @param opts.action {string} Action\n   * @param opts.payload {string} Payload\n   * @returns {boolean|void}\n   */\n\n  /**\n   * Returns the DataField list of the model\n   * @member {GraphandModelList}\n   */\n  static get dataFieldsList() {\n    if (!this.queryFields) {\n      return;\n    }\n\n    const DataField = this._client.getModel(\"DataField\");\n\n    if (!this._dataFieldsList) {\n      let query: Query = { query: { scope: this.scope } };\n\n      if (this._fieldsIds) {\n        if (this._client._options.subscribeFields) {\n          const initList = this._fieldsIds.map((id) => DataField.get(id, false));\n          if (initList.every(Boolean)) {\n            const cacheKey = DataField.getCacheKey(query);\n            DataField._cache[cacheKey] = {\n              rows: initList,\n              count: initList.length,\n            };\n          }\n        } else {\n          query = { ids: this._fieldsIds };\n        }\n      }\n\n      this._dataFieldsList = DataField.getList(query);\n    }\n\n    return this._dataFieldsList;\n  }\n\n  static get fields() {\n    return this.getFields();\n  }\n\n  static get HistoryModel(): typeof GraphandModel {\n    const modelName = `${this.scope}_history`;\n    const parent = this;\n    if (!this._client._models[modelName]) {\n      const GraphandHistoryModel = require(\"./GraphandHistoryModel\").default;\n      const HistoryModel = class extends GraphandHistoryModel {\n        static baseUrl = `${parent.baseUrl}/history`;\n        static queryUrl = `${parent.baseUrl}/history`;\n\n        static get scope() {\n          return modelName;\n        }\n      };\n\n      this._client.registerModel(HistoryModel, { name: modelName });\n    }\n\n    return this._client.models[modelName];\n  }\n\n  /**\n   * Returns raw data of instance\n   * @returns {*}\n   */\n  get raw() {\n    return this._data;\n  }\n\n  get _translations() {\n    const translations = this._data.translations ? Object.keys(this._data.translations) : [];\n    return translations.concat(this._model._client._project?.defaultLocale);\n  }\n\n  get HistoryModel(): typeof GraphandModel {\n    const constructor = this._model;\n    const modelName = `${constructor.scope}_${this._id}_history`;\n    const parent = this;\n    if (!constructor._client._models[modelName]) {\n      const GraphandHistoryModel = require(\"./GraphandHistoryModel\").default;\n      const HistoryModel = class extends GraphandHistoryModel {\n        static baseUrl = `${constructor.baseUrl}/${parent._id}/history`;\n        static queryUrl = `${constructor.baseUrl}/${parent._id}/history`;\n\n        static get scope() {\n          return modelName;\n        }\n      };\n\n      constructor._client.registerModel(HistoryModel, { name: modelName });\n    }\n\n    return constructor._client.models[modelName];\n  }\n\n  /**\n   * Hydrate GraphandModel or GraphandModelList from serialized data\n   * @param data {any} - Serialized data\n   * @param upsert {boolean} - Upsert hydrated data in store\n   * @returns {GraphandModel|GraphandModelList}\n   */\n  static hydrate(data: any, upsert?: boolean) {\n    return hydrateModel(this, data, upsert);\n  }\n\n  /**\n   * Sync the current Model with the client socket\n   * @param opts {Object}\n   * @param opts.handleSocketTrigger {GraphandModel.sync.handleSocketTrigger} - middleware to allow or disallow the model to proceed data when receiving on socket\n   * @param opts.force {boolean} - force Model to resubscribe on socket (even if already subscribed)\n   */\n  static sync(opts: { handleSocketTrigger?: ({ action, payload }) => boolean | void; force?: boolean } = {}) {\n    const force = typeof opts === \"boolean\" ? opts : opts.force ?? false;\n\n    if (force || (this._client && !this._socketSubscription)) {\n      this._socketOptions = opts;\n      this._socketSubscription = this._client._socketSubject.subscribe((socket) => this.setupSocket(socket));\n    }\n\n    return this;\n  }\n\n  static setPrototypeFields(assignTo?: any) {\n    const fields = this.getFields();\n    const properties = Object.keys(fields)\n      .filter((slug) => slug !== \"_id\")\n      .reduce((final, slug) => {\n        const field = fields[slug];\n        if (!field || field.assign === false) {\n          return final;\n        }\n\n        final[slug] = {\n          enumerable: true,\n          configurable: true,\n          get: function () {\n            return this.get(slug);\n          },\n          set(v) {\n            return this.set(slug, v);\n          },\n        };\n\n        return final;\n      }, {});\n\n    assignTo = assignTo ?? this.prototype;\n    Object.defineProperties(assignTo, properties);\n  }\n\n  static get<C extends typeof GraphandModel, T extends false>(this: C, query?: string | Query, fetchOrOpts?: T, cache?): InstanceType<C>;\n  static get<C extends typeof GraphandModel, T extends FetchOptions>(\n    this: C,\n    query?: string | Query,\n    fetchOrOpts?: T,\n    cache?,\n  ): GraphandModelPromise<InstanceType<C>>;\n  /**\n   * Returns a GraphandModel (or Promise) of the model\n   * @param query {string|Query} - the requested _id or the request query (see api doc)\n   * @param opts\n   * @returns {GraphandModel|GraphandModelPromise}\n   */\n  static get<C extends typeof GraphandModel, T extends FetchOptions | boolean>(\n    this: C,\n    query?: string | Query,\n    fetchOrOpts?: T,\n    cache?,\n  ): InstanceType<C> | GraphandModelPromise<InstanceType<C>> {\n    return getModelInstance(this, query, fetchOrOpts, cache);\n  }\n\n  /**\n   * Get the real model schema fields (custom + system + data)\n   * @param [cache] {boolean} - Default true. Returns cached fields\n   * @returns {Object}\n   */\n  static getFields(cache = true) {\n    if (cache && this._cachedFields) {\n      return this._cachedFields;\n    }\n\n    const fields = {\n      _id: new GraphandFieldId(),\n      ...this._dataFields,\n      ...this.schema,\n    };\n\n    const customFields = Object.keys(this._customFields).reduce((final, slug) => {\n      const input = this._customFields[slug];\n      const field = typeof input === \"function\" ? input(fields) : input;\n\n      if (field && !(field instanceof GraphandField)) {\n        console.warn(`Field ${slug} is not an instance of GraphandField`);\n        return final;\n      }\n\n      final[slug] = field;\n      return final;\n    }, {});\n\n    if (Object.keys(customFields).length) {\n      Object.assign(fields, customFields);\n    }\n\n    this._cachedFields = fields;\n    return fields;\n  }\n\n  /**\n   * Add a custom field to Model\n   * @param slug {string} - The field identifier\n   * @param field {GraphandField} - The GraphandField instance\n   */\n  static customField(slug, field) {\n    this._customFields[slug] = field;\n    this._cachedFields = null;\n    return this;\n  }\n\n  /**\n   * @callback GraphandModelHookHandler\n   * @params payload {Object} - The payload sent by the server\n   * @param resolve {string} - Callback to resolve the handler and validate the sockethook workflow\n   * @param reject {string} - Callback to reject the handler and put error in the sockethook workflow\n   * @returns {*|void}\n   */\n\n  /**\n   * Add multiple customFields\n   * @param fields {Object.<string, number>} - example: { customField: new GraphandFieldText() }\n   */\n  static customFields(fields: { [key: string]: GraphandField | ((fields: typeof GraphandModel.schema) => GraphandField | null) } = {}) {\n    this._customFields = { ...this._customFields, ...fields };\n    this._cachedFields = null;\n    return this;\n  }\n\n  static async _init(force = false) {\n    if (!this._client) {\n      throw new Error(`Model ${this.scope} is not register. Please use Client.registerModel() before`);\n    }\n\n    if (this._initialized) {\n      return;\n    }\n\n    Object.defineProperty(this, \"name\", { value: this.scope });\n\n    if (force || !this._initPromise) {\n      this._initPromise = new Promise(async (resolve, reject) => {\n        try {\n          if (this.initialize) {\n            await this.initialize();\n          }\n\n          if (this.queryFields) {\n            // await this._client._init();\n\n            if (this._client._options.subscribeFields) {\n              await new Promise<void>((resolve) => {\n                this.dataFieldsList.subscribe((list) => {\n                  this.setDataFields(list);\n                  resolve();\n                });\n              });\n            } else if (this._client._options.project) {\n              await this.setDataFields();\n            }\n          }\n\n          this._cachedFields = null;\n          this.setPrototypeFields();\n\n          this._initialized = new Date();\n\n          resolve(true);\n        } catch (e) {\n          reject(e);\n        }\n      });\n    }\n\n    return this._initPromise;\n  }\n\n  static async setDataFields(dataFields?: any) {\n    dataFields = dataFields ?? (await this.dataFieldsList);\n    const graphandFields = dataFields.map((field) => field.toGraphandField());\n    this._dataFields = dataFields.reduce((final, field, index) => Object.assign(final, { [field.slug]: graphandFields[index] }), {});\n    this._cachedFields = null;\n    return this._dataFields;\n  }\n\n  static setupSocket(socket?) {\n    socket = socket || this._client?.socket;\n    if (!socket || !socket.id) {\n      return;\n    }\n\n    const path = \"/models/\" + this.scope;\n    const trigger = async ({ action, payload }) => {\n      if (!payload) {\n        return;\n      }\n\n      if (typeof this._socketOptions?.handleSocketTrigger === \"function\") {\n        const res = await this._socketOptions.handleSocketTrigger({ action, payload });\n        if (res === false) {\n          return;\n        }\n      }\n\n      this._socketTriggerSubject.next({ action, payload });\n\n      let storeUpdated;\n      switch (action) {\n        case \"create\":\n        case \"update\":\n          const items = this.hydrate(payload) as GraphandModelList<GraphandModel>;\n          storeUpdated = this.upsertStore(items);\n          break;\n        case \"delete\":\n          storeUpdated = this.deleteFromStore(payload);\n          break;\n      }\n\n      if (storeUpdated) {\n        this.clearCache();\n      }\n    };\n\n    socket.off(path);\n    socket.on(path, (data) => setTimeout(() => trigger(data)));\n  }\n\n  static async handleUpdateCall(payload, config) {\n    return await this._client._axios.patch(this.baseUrl, payload, config);\n  }\n\n  static handleUpdatedData(rows, upsert = false) {\n    const items = this.hydrate(rows) as GraphandModelList<GraphandModel>;\n\n    if (upsert) {\n      const upserted = this.upsertStore(items);\n\n      if (upserted) {\n        this.clearCache();\n\n        items.forEach((item) => item.HistoryModel.clearCache());\n      }\n    }\n\n    return items;\n  }\n\n  /**\n   * [admin only] Register a new sockethook on the model. The host that register the sockethook needs to keep connection with graphand. Use {@link GraphandModel#on} for example in a node.js script\n   * @param events {\"before_create\"|\"after_create\"|\"before_update\"|\"after_update\"|\"before_delete\"|\"after_delete\"|\"before_execute\"|\"after_execute\"|\"before_login\"|\"after_login\"|\"before_register\"|\"after_register\"} - The event that will trigger the sockethook\n   * @param handler {GraphandModelHookHandler} - The handler that will be executed\n   * @param options\n   */\n  static on(\n    events: (ServerHooksEvents | string) | (ServerHooksEvents | string)[],\n    handler: RegisterHookOptions[\"handler\"],\n    options: RegisterHookOptions & { await?: boolean } = {},\n  ) {\n    this._client.registerHook({ events, handler, model: this, _await: options.await, ...options });\n  }\n\n  static unsync() {\n    this._socketSubscription.unsubscribe();\n    delete this._socketSubscription;\n    this._listSubject.unsubscribe();\n  }\n\n  /**\n   * Reinitialize the model (clear cache & empty store)\n   */\n  static reinit() {\n    this.clearCache(undefined, true);\n    return this;\n  }\n\n  static getCacheKey(input: Query) {\n    const { populate, sort, pageSize, page, translations, query, ids, count } = input;\n    return JSON.stringify({\n      project: this._client._options.project,\n      scope: this.scope,\n      populate,\n      sort,\n      pageSize,\n      page,\n      translations,\n      query,\n      ids,\n      count: !!count,\n    });\n  }\n\n  /**\n   * Clear the local cache for the model\n   * @param query {any} - If specified, clear only the cache for this query\n   * @param clean {boolean} - Default false. If true, the local model store will be reinitialized\n   */\n  static clearCache(query?, clean = false) {\n    if (query) {\n      const cacheKey = this.getCacheKey(query);\n      delete this._cache[cacheKey];\n    } else {\n      this._cache = {};\n    }\n\n    if (clean) {\n      this.reinitStore();\n    }\n\n    return this;\n  }\n\n  static clearRelationsCache() {\n    const fields = this.getFields();\n    Object.values(fields)\n      .filter((field) => field instanceof GraphandFieldRelation)\n      .forEach((field: any) => {\n        if (field.ref !== this.scope) {\n          const model = this._client.getModel(field.ref);\n          model?.clearCache();\n        }\n      });\n  }\n\n  static reinitStore() {\n    this._listSubject.next([]);\n\n    return this;\n  }\n\n  static deleteFromStore(payload: GraphandModel[] | string[], force = false) {\n    let refresh = false;\n    const _delete = (list, item) => {\n      const _id = isId(item) ? item : item._id;\n      const found = list.find((i) => i._id === _id);\n      if (found) {\n        refresh = true;\n      }\n      return [...list.filter((i) => i !== found)];\n    };\n\n    let _list: any = this.getList();\n    payload.forEach((item) => (_list = _delete(_list, item)));\n\n    if (force || refresh) {\n      // this.clearRelationsCache();\n      this._listSubject.next(_list);\n      return true;\n    }\n\n    return false;\n  }\n\n  static upsertStore(payload: GraphandModel[] | GraphandModelList<GraphandModel>, force = false) {\n    let refresh = false;\n    const _upsert = (list, item) => {\n      const found: GraphandModel = list.find((i) => i._id === item._id);\n\n      if (!found) {\n        refresh = true;\n        return list.concat(item);\n      }\n\n      if (force || item.updatedAt > found.updatedAt) {\n        refresh = true;\n        found.assign(item._data, false, false);\n        return list;\n      }\n\n      return list;\n    };\n\n    let _list = this.getList();\n    payload.forEach((item) => (_list = _upsert(_list, item)));\n\n    if (refresh) {\n      this._listSubject.next(_list);\n      return true;\n    }\n\n    return false;\n  }\n\n  static getList<T extends typeof GraphandModel>(this: T, query?: undefined, opts?: ModelListOptions | boolean): GraphandModelList<InstanceType<T>>;\n  static getList<T extends typeof GraphandModel>(\n    this: T,\n    query: Query,\n    opts?: ModelListOptions | boolean,\n  ): GraphandModelList<InstanceType<T>> | GraphandModelListPromise<InstanceType<T>>;\n\n  /**\n   * Returns a GraphandModelList (or Promise) of the model. If no query provided, returns all the cached instances\n   * @param query {Query} - the request query (see api doc)\n   * @param opts\n   * @returns {GraphandModelList|GraphandModelListPromise}\n   * @example GraphandModel.getList({ query: { title: { $regex: \"toto\" } }, pageSize: 5, page: 2 })\n   * @example GraphandModel.getList().find((instance) => instance.title === \"toto\")\n   */\n  static getList<T extends typeof GraphandModel>(\n    this: T,\n    query: Query,\n    opts?: ModelListOptions | boolean,\n  ): GraphandModelList<InstanceType<T>> | GraphandModelListPromise<InstanceType<T>> {\n    if (!query) {\n      const list = this._listSubject.getValue()||[];\n      return new GraphandModelList<InstanceType<T>>({ model: this }, ...list);\n    }\n\n    return getModelList(this, query, opts);\n  }\n\n  static query(query: any, opts: ModelListOptions | boolean = true) {\n    return getModelList(this, query, opts);\n  }\n\n  /**\n   * Returns a Promise that resolves the number of results for the given query\n   * @param query {Query} - the request query (see api doc)\n   * @returns {number}\n   * @example GraphandModel.count({ query: { title: { $regex: \"toto\" } } })\n   */\n  static async count(query?: Query): Promise<number> {\n    if (typeof query === \"string\") {\n      query = { query: { _id: query } };\n    } else if (!query) {\n      query = {};\n    }\n\n    if (query.query) {\n      query.query = parseQuery(query.query);\n    }\n\n    const { data } = await this._client._axios.post(`${this.baseUrl}/count`, query);\n    return parseInt(data.data, 10);\n  }\n\n  /**\n   * Create and persist a new instance of the model\n   * @param payload {Object|Object[]} - The payload to persist in a new instance. You can profite an array to create multiple instances\n   * @param hooks {boolean} - Enable or disable hooks, default true\n   * @returns {GraphandModel}\n   * @example GraphandModel.create({ title: \"toto\" })\n   */\n  static create<T extends typeof GraphandModel>(\n    this: T,\n    payload: Partial<{ [key in keyof InstanceType<T>]: InstanceType<T>[key] | any }>,\n    hooks = true,\n    url = this.baseUrl,\n  ): Promise<InstanceType<T>> {\n    return createModel(this, payload, hooks, url);\n  }\n\n  static refreshList() {\n    this._listSubject.next(this.getList());\n  }\n\n  // constructor\n\n  /**\n   * Update one or multiple instances by query\n   * @param update {Update} - query and payload to apply\n   * @param [options]\n   * @example\n   * // set title toto on every instance in the query scope\n   * GraphandModel.create({ query: { title: { $ne: \"toto\" } }, set: { title: \"toto\" } })\n   */\n  static async update(\n    update: Update,\n    options?: { hooks?: boolean; clearCache?: boolean; upsert?: boolean; preStore?: boolean; revertOnError?: boolean },\n  ) {\n    return updateModel(this, update, options);\n  }\n\n  // getters\n\n  /**\n   * Delete one or multiple instances by query\n   * @param del {GraphandModel|Query} - query of target instances to delete (ex: { query: { ... } })\n   * @param [options]\n   * @returns {boolean} - is deleted\n   * @example\n   * GraphandModel.delete({ query: { title: { $ne: \"toto\" } } })\n   */\n  static async delete(del: GraphandModel | Query, options?: { hooks?: boolean; clearCache?: boolean; updateStore?: boolean }): Promise<boolean> {\n    return deleteModel(this, del, options);\n  }\n\n  static async serializeModel(clearCache = false) {\n    const dataFields = await this.dataFieldsList;\n    return JSON.stringify({\n      fieldsIds: this._fieldsIds,\n      fields: dataFields?.toJSON(),\n    });\n  }\n\n  static rebuildModel(serial) {\n    const DataField = this._client.getModel(\"DataField\");\n\n    const { fields, fieldsIds } = JSON.parse(serial);\n    this._fieldsIds = fieldsIds;\n\n    const dataFields = fields.map((f) => DataField.hydrate(f));\n    this.setDataFields(dataFields);\n  }\n\n  // helpers\n\n  static async serializeFromId(_id) {\n    await this._init();\n\n    const [obj, modelSerial] = await Promise.all([this.get(_id), this.serializeModel()]);\n\n    return {\n      res: obj.serialize(),\n      modelSerial,\n    };\n  }\n\n  static rebuildFromSerial(serial) {\n    const { res, modelSerial } = serial;\n\n    this.rebuildModel(modelSerial);\n    const data = JSON.parse(res);\n    return this.hydrate(data);\n  }\n\n  /**\n   * Execute all hooks for an event. Returns an array of the reponses of each hook callback.\n   * @param event {\"preCreate\"|\"postCreate\"|\"preUpdate\"|\"postUpdate\"|\"preDelete\"|\"postDelete\"} - The event to execute. Graphand plugins can also implements new events\n   * @param args {any} - Args passed to the callbacks functions\n   * @returns {Promise<any[]>}\n   */\n  static async execHook<T extends ClientHooksEvents | string, M extends typeof GraphandModel>(\n    this: M,\n    event: T,\n    args: ClientHookArgs<T, InstanceType<M>>,\n  ): Promise<any[]> {\n    const hook = this.getHook(event);\n    if (!hook?.length) {\n      return;\n    }\n\n    return Promise.all(hook.map((fn) => fn.apply(this, args)));\n  }\n\n  static getHook(event) {\n    const hook = this._hooks[event] ? [...this._hooks[event]] : [];\n\n    if (super.__proto__ && \"getHook\" in super.__proto__) {\n      return super.__proto__.getHook(event).concat(hook);\n    }\n\n    return hook;\n  }\n\n  /**\n   * Add hook on model\n   * @param event {\"preCreate\"|\"postCreate\"|\"preUpdate\"|\"postUpdate\"|\"preDelete\"|\"postDelete\"} - The event to listen. Graphand plugins can also implements new events\n   * @param callback\n   */\n  static hook<T extends ClientHooksEvents | string, M extends typeof GraphandModel>(\n    this: M,\n    event: T,\n    callback: ClientHookCallback<T, InstanceType<M>>,\n  ) {\n    this._hooks[event] = this._hooks[event] || new Set();\n    this._hooks[event].add(callback);\n  }\n\n  /**\n   * Update current instance\n   * @param update {Update} - payload to apply. Query is already set with current instance id\n   * @param [options]\n   * @example\n   * // set title toto on the current instance\n   * this.update({ set: { ...payload } })\n   */\n  async update(update: Update, options?: { hooks?: boolean; clearCache?: boolean; upsert?: boolean; preStore?: boolean; revertOnError?: boolean }) {\n    await updateModelInstance(this, update, options);\n    return this;\n  }\n\n  /**\n   * Delete current instance\n   * @param [options]\n   * @example\n   * this.delete().then(() => console.log(\"deleted\"))\n   */\n  delete(options?: { hooks?: boolean; clearCache?: boolean; updateStore?: boolean }) {\n    const constructor = this.constructor as any;\n    return constructor.delete(this, options);\n  }\n\n  populate(paths?) {\n    this._data = processPopulate(this._data, this._model.getFields(), this._model._client, paths);\n    return this;\n  }\n\n  translate(locale) {\n    if (this._model.translatable) {\n      this._locale = locale;\n    }\n\n    return this;\n  }\n\n  /**\n   * Clone the instance\n   * @param locale\n   */\n  clone(locale?) {\n    const clone = new this._model(this.raw ? copy(parsePayload(this.raw)) : {});\n    if (locale) {\n      clone.translate(locale);\n    }\n\n    return clone as typeof this;\n  }\n\n  /**\n   * Model instance getter. Returns the value for the specified key\n   * @param slug {string} - The key (field slug) to get\n   * @param parse {boolean=} - Default true. If false returns raw value\n   * @param _locale\n   * @param fallback\n   */\n  get(slug, parse = true, _locale = this._locale, fallback = true) {\n    const constructor = this._model;\n    const field = constructor.fields[slug];\n    if (!field) {\n      return undefined;\n    }\n\n    let value = this._data[slug];\n\n    if (value === undefined && slug.includes(\".\")) {\n      value = lodashGet(this._data, slug);\n    }\n\n    if (constructor.translatable) {\n      const locale = _locale || constructor._client.locale;\n      if (locale && constructor._client._project?.locales?.includes(locale) && locale !== constructor._client._project.defaultLocale) {\n        const translationValue = lodashGet(this._data, `translations.${locale}.${slug}`);\n        value = fallback && translationValue !== undefined ? value : translationValue;\n      }\n    }\n\n    if (value === undefined) {\n      value = field.defaultValue;\n    }\n\n    if (parse && field?.getter) {\n      value = field.getter(value, this);\n    }\n\n    return value;\n  }\n\n  /**\n   * Model instance setter. Set value for the specified key\n   * @param slug {string} - The key (field slug) to get\n   * @param value {*}\n   * @param upsert {boolean=} - Define if the setter will trigger a store upsert action\n   * @param parse {boolean=} - Default true. If false set raw value\n   */\n  set(slug: string, value: any, upsert?: boolean, parse = true) {\n    const field = this._model.getFields()[slug];\n\n    upsert = upsert ?? (field && ![\"_id\", \"createdAt\", \"createdBy\", \"updatedAt\", \"updatedBy\"].includes(slug));\n\n    if (parse && field?.setter) {\n      value = field.setter(value, this);\n    }\n\n    if (upsert) {\n      return this.assign({ [slug]: value });\n    } else {\n      lodashSet(this._data, slug, value);\n    }\n\n    return this;\n  }\n\n  /**\n   * Assign multiple values to instance.\n   * @param values {Object}\n   * @param upsert {boolean=} - Define if the setter will trigger a store upsert action\n   */\n  assign(values?: any, upsert = true, updatedAtNow = true) {\n    values = values && parsePayload(values);\n\n    if (!upsert) {\n      if (values?._id) {\n        this._data = values;\n      } else if (values) {\n        Object.keys(values).forEach((key) => {\n          this.set(key, values[key], false);\n        });\n      }\n\n      if (updatedAtNow) {\n        this.updatedAt = new Date();\n      }\n\n      return this;\n    }\n\n    const clone = this.clone();\n    if (updatedAtNow) {\n      clone.updatedAt = new Date();\n    }\n\n    if (values?._id) {\n      clone._data = values;\n    } else if (values) {\n      Object.keys(values).forEach((key) => {\n        clone.set(key, values[key], false);\n      });\n    }\n\n    const upserted = this._model.upsertStore([clone], true);\n    this._data = clone._data;\n\n    return this;\n  }\n\n  createObservable() {\n    this._observable = new Observable((subscriber) => {\n      let lastUpdated = this.updatedAt;\n\n      const _updater = async (_list) => {\n        await new Promise((resolve) => setTimeout(resolve));\n        const item = this.isTemporary() ? _list.find((i) => i._id === this._id) : await this._model.get(this._id);\n\n        if (!item || item.updatedAt > lastUpdated) {\n          if (item) {\n            lastUpdated = item.updatedAt;\n          }\n          subscriber.next(item);\n        }\n      };\n\n      this._storeSub = this._model._listSubject.subscribe(_updater);\n    });\n  }\n\n  /**\n   * Subscribe to the current instance. The callback will be called each time the instance is updated in store.\n   * If the model is synced (realtime), the callback will be called when the instance is updated via socket\n   * @param callback - The function to call when the instance is updated\n   */\n  subscribe(callback): Subscription {\n    if (!this._observable) {\n      this.createObservable();\n    }\n\n    const sub = this._observable.subscribe(callback);\n    this._subscriptions.add(sub);\n    const unsubscribe = sub.unsubscribe;\n    sub.unsubscribe = () => {\n      unsubscribe.apply(sub);\n      this._subscriptions.delete(sub);\n\n      if (!this._subscriptions.size) {\n        this._storeSub?.unsubscribe();\n        delete this._observable;\n      }\n    };\n\n    sub.next(this);\n    return sub;\n  }\n\n  /**\n   * Returns true if the current instance is only in memory and not persisted on Graphand.\n   */\n  isTemporary() {\n    return this._id.startsWith(\"_\");\n  }\n\n  reloadFields() {\n    this._model.setPrototypeFields(this);\n  }\n\n  encodeQuery() {\n    return this._id;\n  }\n\n  // format\n\n  refresh() {\n    const newItem = this._model.get(this._id, false);\n    this.assign(newItem, false);\n    return this;\n  }\n\n  getInvertedRelation(model: typeof GraphandModel, query, opts, ...args) {\n    model = typeof model === \"string\" ? this._model._client.getModel(model) : model;\n    query = typeof query === \"object\" ? query : { [query]: this._id };\n    return model.getList({ ...opts, query }, ...args);\n  }\n\n  /**\n   * Serialize instance. Serialized data could be hydrated with GraphandModel.hydrate\n   * @returns {Object}\n   */\n  serialize() {\n    return { __type: \"GraphandModel\", __scope: this._model.scope, __payload: this._data };\n  }\n\n  toObject() {\n    const fields = this._model.getFields();\n    return Object.keys(fields).reduce((final, slug) => Object.assign(final, { [slug]: this.get(slug) }), {});\n  }\n\n  /**\n   * Returns JSON-serialized object of the current instance\n   * @return {Object}\n   */\n  toJSON<T extends GraphandModel>(this: T): Partial<T> {\n    const fields = this._model.getFields();\n    return Object.keys(fields).reduce((final, slug) => {\n      return Object.assign(final, { [slug]: this.get(slug, false) });\n    }, {});\n  }\n\n  toString(): string {\n    return this._id;\n  }\n}\n\nGraphandModel.customFields({\n  createdBy: new GraphandFieldRelation({\n    ref: \"Account\",\n    multiple: false,\n  }),\n  createdAt: new GraphandFieldDate({\n    time: true,\n  }),\n  updatedBy: new GraphandFieldRelation({\n    ref: \"Account\",\n    multiple: false,\n  }),\n  updatedAt: new GraphandFieldDate({\n    time: true,\n  }),\n});\n\nexport default GraphandModel;\n"
        }
    ]
}